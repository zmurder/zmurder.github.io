<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8693861384618000"
     crossorigin="anonymous"></script>
  <meta name="msvalidate.01" content="7EC20DBC74B004C2782077570E15C280">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8693861384618000"
     crossorigin="anonymous"></script>
    <meta name="description" content="7. 如何使用TensorRT中的INT8下面的内容实际上是根据TensorRT版本的更新是会变化的，这里的版本是8.4.1">
<meta property="og:type" content="article">
<meta property="og:title" content="7-TensorRT中的INT8">
<meta property="og:url" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/index.html">
<meta property="og:site_name" content="奔跑的IC">
<meta property="og:description" content="7. 如何使用TensorRT中的INT8下面的内容实际上是根据TensorRT版本的更新是会变化的，这里的版本是8.4.1">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519153232620.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/8-bit-signed-integer-quantization.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519164204069.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519153839309.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/tensorrt-ptq-workflow.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519154307201.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519154318728.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519154338674.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-propagation.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement1.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement2.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement3.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement4.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement5.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement6.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/sub-optimal.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-limitations.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519160545371.png">
<meta property="og:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519160746455.png">
<meta property="article:published_time" content="2024-12-01T10:13:45.385Z">
<meta property="article:modified_time" content="2024-12-01T10:13:45.386Z">
<meta property="article:author" content="奔跑的IC">
<meta property="article:tag" content="git">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="GPU">
<meta property="article:tag" content="Tensorrt">
<meta property="article:tag" content="DeepLearning">
<meta property="article:tag" content="卷积神经网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519153232620.png">


<link rel="canonical" href="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/","path":"TensorRT/TensorRT中文版开发手册/7-TensorRT中的INT8/","title":"7-TensorRT中的INT8"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>7-TensorRT中的INT8 | 奔跑的IC</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">奔跑的IC</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-reorder fa-fw"></i>文章列表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8TensorRT%E4%B8%AD%E7%9A%84INT8"><span class="nav-text">7. 如何使用TensorRT中的INT8</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Introduction-to-Quantization"><span class="nav-text">7.1. Introduction to Quantization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-Quantization-Workflows"><span class="nav-text">7.1.1. Quantization Workflows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-Explicit-vs-Implicit-Quantization"><span class="nav-text">7.1.2. Explicit vs Implicit Quantization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-3-Per-Tensor-and-Per-Channel-Quantization"><span class="nav-text">7.1.3. Per-Tensor and Per-Channel Quantization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-Setting-Dynamic-Range"><span class="nav-text">7.2. Setting Dynamic Range</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-Post-Training-Quantization-using-Calibration"><span class="nav-text">7.3. Post-Training Quantization using Calibration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-INT8-Calibration-Using-C"><span class="nav-text">7.3.1. INT8 Calibration Using C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-Calibration-Using-Python"><span class="nav-text">7.3.2. Calibration Using Python</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-Explicit-Quantization"><span class="nav-text">7.4. Explicit Quantization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-Quantized-Weights"><span class="nav-text">7.4.1. Quantized Weights</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-ONNX-Support"><span class="nav-text">7.4.2. ONNX Support</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-TensorRT-Processing-Of-Q-DQ-Networks"><span class="nav-text">7.4.3. TensorRT Processing Of Q&#x2F;DQ Networks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-4-Q-DQ-Layer-Placement-Recommendations"><span class="nav-text">7.4.4. Q&#x2F;DQ Layer-Placement Recommendations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-5-Q-DQ-Limitations"><span class="nav-text">7.4.5. Q&#x2F;DQ Limitations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-6-QAT-Networks-Using-TensorFlow"><span class="nav-text">7.4.6. QAT Networks Using TensorFlow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-7-QAT-Networks-Using-PyTorch"><span class="nav-text">7.4.7. QAT Networks Using PyTorch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-INT8-Rounding-Modes"><span class="nav-text">7.5. INT8 Rounding Modes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-Calibration-file"><span class="nav-text">7.6 Calibration file</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TIPS"><span class="nav-text">TIPS:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A"><span class="nav-text">附录：</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="奔跑的IC"
      src="/images/zyd.gif">
  <p class="site-author-name" itemprop="name">奔跑的IC</p>
  <div class="site-description" itemprop="description">死磕牛角的IT农民工</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zyd.gif">
      <meta itemprop="name" content="奔跑的IC">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔跑的IC">
      <meta itemprop="description" content="死磕牛角的IT农民工">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="7-TensorRT中的INT8 | 奔跑的IC">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          7-TensorRT中的INT8
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-01 18:13:45" itemprop="dateCreated datePublished" datetime="2024-12-01T18:13:45+08:00">2024-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TensorRT/" itemprop="url" rel="index"><span itemprop="name">TensorRT</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" itemprop="url" rel="index"><span itemprop="name">TensorRT中文版开发手册</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="7-如何使用TensorRT中的INT8"><a href="#7-如何使用TensorRT中的INT8" class="headerlink" title="7. 如何使用TensorRT中的INT8"></a>7. 如何使用TensorRT中的INT8</h1><p>下面的内容实际上是根据TensorRT版本的更新是会变化的，这里的版本是8.4.1</p>
<p>下面的思维导图是自己理解的总结。具体详细内容需要根据自己的TensorRT版本去查询对应的官方文档。</p>
<p>关于历史版本TensorRT的文档在官方文档：<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/tensorrt/index.html">NVIDIA TensorRT</a>最下面</p>
<p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/tensorrt/archives/index.html">Documentation Archives</a>中有对应版本文档的链接。</p>
<p>模型量化是一种流行的深度学习优化方法，其中模型数据（包括网络参数和激活）从浮点表示转换为低精度表示，通常使用8位整数。这有几个好处：</p>
<ul>
<li>在处理8位整数数据时，NVIDIA GPU使用更快、更便宜的8位张量核来计算卷积和矩阵乘法运算。这会产生更多的计算吞吐量，这在计算受限的层上尤其有效。</li>
<li>将数据从内存移动到计算元件（NVIDIA GPU中的流式多处理器）需要时间和精力，还会产生热量。将激活和参数数据的精度从32位浮点值降低到8位整数，可以减少4倍的数据，从而节省电力并减少产生的热量。</li>
<li>有些层有带宽限制（内存有限）。这意味着它们的实现将大部分时间花在读取和写入数据上，因此减少它们的计算时间并不会减少它们的总体运行时间。带宽绑定层从减少的带宽需求中获益最多。</li>
<li>内存占用空间的减少意味着该模型所需的存储空间更少，参数更新更小，缓存利用率更高，等等。</li>
</ul>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519153232620.png" class="" title="image-20240519153232620">
<p>具体看下图非常直观</p>
<p>参考 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/blog/achieving-fp32-accuracy-for-int8-inference-using-quantization-aware-training-with-tensorrt/">https://developer.nvidia.com/blog/achieving-fp32-accuracy-for-int8-inference-using-quantization-aware-training-with-tensorrt/</a></p>
<p>参考<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/8-bit-signed-integer-quantization.png" class="" title="8-bit-signed-integer-quantization"></p>
<p>下图是官方文档 8-bit-inference-with-tensorrt.pdf文档的描述</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519164204069.png" class="" title="image-20240519164204069">
<p><strong>如何解决上面的两种误差带来的精度损失？</strong></p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519153839309.png" class="" title="image-20240519153839309">
<p>下图是PTQ的两种方式<br><em>Figure 3. TensorRT PTQ workflow</em> (left) <em>vs. TensorRT INT8 quantization using quantization scales derived from the configured tensors dynamic-range</em> (right)</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/tensorrt-ptq-workflow.png" class="" title="tensorrt-ptq-workflow">
<h2 id="7-1-Introduction-to-Quantization"><a href="#7-1-Introduction-to-Quantization" class="headerlink" title="7.1. Introduction to Quantization"></a>7.1. Introduction to Quantization</h2><p>TensorRT 支持使用 8 位整数来表示量化的浮点值。量化方案是对称均匀量化 - 量化值以有符号 INT8 表示，从量化到非量化值的转换只是一个乘法。在相反的方向上，量化使用倒数尺度，然后是舍入和钳位。</p>
<p>要启用任何量化操作，必须在构建器配置中设置 INT8 标志。</p>
<h3 id="7-1-1-Quantization-Workflows"><a href="#7-1-1-Quantization-Workflows" class="headerlink" title="7.1.1. Quantization Workflows"></a>7.1.1. Quantization Workflows</h3><p>创建量化网络有两种工作流程：</p>
<p>训练后量化(PTQ: Post-training quantization) 在网络经过训练后得出比例因子。 TensorRT 为 PTQ 提供了一个工作流程，称为校准(<code>calibration</code>)，当网络在代表性输入数据上执行时，它测量每个激活张量内的激活分布，然后使用该分布来估计张量的尺度值。</p>
<p>量化感知训练(QAT: Quantization-aware training) 在训练期间计算比例因子。这允许训练过程补偿量化和去量化操作的影响。</p>
<p>TensorRT 的<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/TensorRT/tree/main/tools/pytorch-quantization">量化工具包</a>是一个 PyTorch 库，可帮助生成可由 TensorRT 优化的 QAT 模型。您还可以利用工具包的 PTQ 方式在 PyTorch 中执行 PTQ 并导出到 ONNX。</p>
<h3 id="7-1-2-Explicit-vs-Implicit-Quantization"><a href="#7-1-2-Explicit-vs-Implicit-Quantization" class="headerlink" title="7.1.2. Explicit vs Implicit Quantization"></a>7.1.2. Explicit vs Implicit Quantization</h3><img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519154307201.png" class="" title="image-20240519154307201">
<p>量化网络可以用两种方式表示：</p>
<p>在隐式量化网络中，每个量化张量都有一个相关的尺度。在读写张量时，尺度用于隐式量化和反量化值。</p>
<p>在处理隐式量化网络时，TensorRT 在应用图形优化时将模型视为浮点模型，并适时的使用 INT8 来优化层执行时间。如果一个层在 INT8 中运行得更快，那么它在 INT8 中执行。否则，使用 FP32 或 FP16。在这种模式下，TensorRT 仅针对性能进行优化，您几乎无法控制 INT8 的使用位置——即使您在 API 级别明确设置层的精度，TensorRT 也可能在图优化期间将该层与另一个层融合，并丢失它必须在 INT8 中执行的信息。 TensorRT 的 PTQ 功能可生成隐式量化网络。</p>
<p>在显式量化的网络中，在量化和未量化值之间转换的缩放操作由图中的<code>IQuantizeLayer</code> ( <a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-api/c_api/classnvinfer1_1_1_i_quantize_layer.html">C++</a> , <a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-api/python_api/infer/Graph/Layers.html#iquantizelayer">Python</a>)和<code>IDequantizeLayer</code> ( <a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-api/c_api/classnvinfer1_1_1_i_dequantize_layer.html">C++</a> , <a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-api/python_api/infer/Graph/Layers.html#idequantizelayer">Python</a> ) 节点显式表示 - 这些节点此后将被称为 Q/DQ 节点。与隐式量化相比，显式形式精确地指定了与 INT8 之间的转换在何处执行，并且优化器将仅执行由模型语义规定的精度转换，即使：</p>
<ul>
<li><p>添加额外的转换可以提高层精度（例如，选择 FP16 内核实现而不是 INT8 实现）</p>
</li>
<li><p>添加额外的转换会导致引擎执行得更快（例如，选择 INT8 内核实现来执行指定为具有浮点精度的层，反之亦然）</p>
</li>
</ul>
<p>ONNX 使用显式量化表示 - 当 PyTorch 或 TensorFlow 中的模型导出到 ONNX 时，框架图中的每个伪量化操作都导出为 Q，然后是 DQ。由于 TensorRT 保留了这些层的语义，因此您可以期望任务准确度非常接近框架中看到的准确度。虽然优化保留了量化和去量化的位置，但它们可能会改变模型中浮点运算的顺序，因此结果不会按位相同。<br>请注意，与 TensorRT 的 PTQ 相比，在框架中执行 QAT 或 PTQ 然后导出到 ONNX 将产生一个明确量化的模型。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519154318728.png" class="" title="image-20240519154318728">
<div class="tablenoborder"><a name="explicit-implicit-quantization__table_tyj_kjm_sqb" shape="rect">
                                    <!-- --></a><table cellpadding="4" cellspacing="0" summary="" id="explicit-implicit-quantization__table_tyj_kjm_sqb" class="table" frame="border" border="1" rules="all">
                                    <caption><span class="tablecap">Table 2. Implicit vs Explicit Quantization</span></caption>
                                    <thead class="thead" align="left">
                                       <tr class="row">
                                          <th class="entry" valign="top" width="33.33333333333333%" id="d54e4235" rowspan="1" colspan="1">&nbsp;</th>
                                          <th class="entry" valign="top" width="33.33333333333333%" id="d54e4237" rowspan="1" colspan="1">Implicit Quantization</th>
                                          <th class="entry" valign="top" width="33.33333333333333%" id="d54e4240" rowspan="1" colspan="1">Explicit Quantization</th>
                                       </tr>
                                    </thead>
                                    <tbody class="tbody">
                                       <tr class="row">
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4235" rowspan="1" colspan="1">User control over precision</td>
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4237" rowspan="1" colspan="1">Little control: INT8 is used in all kernels for which it
                                             accelerates performance.
                                          </td>
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4240" rowspan="1" colspan="1">Full control over quantization/dequantization boundaries.</td>
                                       </tr>
                                       <tr class="row">
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4235" rowspan="1" colspan="1">Optimization criterion</td>
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4237" rowspan="1" colspan="1">Optimize for performance.</td>
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4240" rowspan="1" colspan="1">Optimize for performance while maintaining arithmetic precision
                                             (accuracy).
                                          </td>
                                       </tr>
                                       <tr class="row">
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4235" rowspan="1" colspan="1">API</td>
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4237" rowspan="1" colspan="1"><a name="explicit-implicit-quantization__ul_qp2_pjm_sqb" shape="rect">
                                                <!-- --></a><ul class="ul" id="explicit-implicit-quantization__ul_qp2_pjm_sqb">
                                                <li class="li">Model + Scales (dynamic range API)</li>
                                                <li class="li">Model + Calibration data</li>
                                             </ul>
                                          </td>
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4240" rowspan="1" colspan="1">Model with Q/DQ layers.</td>
                                       </tr>
                                       <tr class="row">
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4235" rowspan="1" colspan="1">Quantization scales</td>
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4237" rowspan="1" colspan="1">
                                             <div class="p">Weights:<a name="explicit-implicit-quantization__ul_kmk_rjm_sqb" shape="rect">
                                                   <!-- --></a><ul class="ul" id="explicit-implicit-quantization__ul_kmk_rjm_sqb">
                                                   <li class="li">Set by TensorRT (internal)</li>
                                                   <li class="li">Range <samp class="ph codeph">[-127, 127]</samp></li>
                                                </ul>
                                             </div>
                                             <div class="p">Activations:<a name="explicit-implicit-quantization__ul_xj5_sjm_sqb" shape="rect">
                                                   <!-- --></a><ul class="ul" id="explicit-implicit-quantization__ul_xj5_sjm_sqb">
                                                   <li class="li">Set by calibration or specified by the user</li>
                                                   <li class="li">Range <samp class="ph codeph">[-128, 127]</samp></li>
                                                </ul>
                                             </div>
                                          </td>
                                          <td class="entry" valign="top" width="33.33333333333333%" headers="d54e4240" rowspan="1" colspan="1">Weights and activations:<a name="explicit-implicit-quantization__ul_z2h_5jm_sqb" shape="rect">
                                                <!-- --></a><ul class="ul" id="explicit-implicit-quantization__ul_z2h_5jm_sqb">
                                                <li class="li">Specified using Q/DQ ONNX operators</li>
                                                <li class="li">Range <samp class="ph codeph">[-128, 127]</samp></li>
                                             </ul>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                              </div>


<p>有关量化的更多背景信息，请参阅深度学习推理的整数量化：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2004.09602">原理和实证评估</a>论文。</p>
<h3 id="7-1-3-Per-Tensor-and-Per-Channel-Quantization"><a href="#7-1-3-Per-Tensor-and-Per-Channel-Quantization" class="headerlink" title="7.1.3. Per-Tensor and Per-Channel Quantization"></a>7.1.3. Per-Tensor and Per-Channel Quantization</h3><img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519154338674.png" class="" title="image-20240519154338674">
<p>有两种常见的量化尺度粒度：</p>
<ul>
<li>每张量量化：其中使用单个比例值（标量）来缩放整个张量。</li>
<li>每通道量化：沿给定轴广播尺度张量 - 对于卷积神经网络，这通常是通道轴。</li>
</ul>
<p>通过显式量化，权重可以使用每张量量化进行量化，也可以使用每通道量化进行量化。在任何一种情况下，比例精度都是 FP32。激活只能使用每张量量化来量化。</p>
<p>当使用每通道量化时，量化轴必须是输出通道轴。例如，当使用<code>KCRS</code>表示法描述 2D 卷积的权重时， K是输出通道轴，权重量化可以描述为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For each k <span class="keyword">in</span> K:</span><br><span class="line">    For each c <span class="keyword">in</span> C:</span><br><span class="line">        For each r <span class="keyword">in</span> R:</span><br><span class="line">            For each s <span class="keyword">in</span> S:</span><br><span class="line">                output[k,c,r,s] := clamp(<span class="built_in">round</span>(<span class="built_in">input</span>[k,c,r,s] / scale[k]))</span><br></pre></td></tr></table></figure>
<p>比例尺是一个系数向量，必须与量化轴具有相同的大小。量化尺度必须由所有正浮点系数组成。四舍五入方法是四舍五入到最近的关系到偶数，并且钳位在[-128, 127]范围内。</p>
<p>除了定义为的逐点操作外，反量化的执行方式类似：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output[k,c,r,s] := <span class="built_in">input</span>[k,c,r,s] * scale[k]</span><br></pre></td></tr></table></figure><br>TensorRT 仅支持激活张量的每张量量化，但支持卷积、反卷积、全连接层和 MatMul 的每通道权重量化，其中第二个输入是常数且两个输入矩阵都是二维的。</p>
<h2 id="7-2-Setting-Dynamic-Range"><a href="#7-2-Setting-Dynamic-Range" class="headerlink" title="7.2. Setting Dynamic Range"></a>7.2. Setting Dynamic Range</h2><p>TensorRT 提供 API 来直接设置动态范围（必须由量化张量表示的范围），以支持在 TensorRT 之外计算这些值的隐式量化。</p>
<ul>
<li>手动API设置动态范围（可以覆盖INT8校准生动态范围）</li>
<li>INT8校准生动态范围</li>
</ul>
<p>API 允许使用最小值和最大值设置张量的动态范围。由于 TensorRT 目前仅支持对称范围，因此使用<code>max(abs(min_float), abs(max_float))</code>计算比例。请注意，当<code>abs(min_float) != abs(max_float)</code>时，TensorRT 使用比配置更大的动态范围，这可能会增加舍入误差。</p>
<ul>
<li><p>将在 INT8 中执行的操作的所有浮点输入和输出都需要动态范围。</p>
</li>
</ul>
<p>您可以按如下方式设置张量的动态范围：<br><strong>C++</strong></p>
<p><strong>tensor-&gt;setDynamicRange(min_float, max_float);</strong></p>
<p><strong>Python</strong></p>
<p><strong>tensor.dynamic_range = (min_float, max_float)</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/NVIDIA/TensorRT/tree/main/samples/sampleINT8API">sampleINT8API</a>说明了这些 API 在 C++ 中的使用。</p>
<h2 id="7-3-Post-Training-Quantization-using-Calibration"><a href="#7-3-Post-Training-Quantization-using-Calibration" class="headerlink" title="7.3. Post-Training Quantization using Calibration"></a>7.3. Post-Training Quantization using Calibration</h2><p>在训练后量化中，TensorRT 计算网络中每个张量的比例值。这个过程称为校准，需要您提供有代表性的输入数据，TensorRT 在其上运行网络以收集每个激活张量的统计信息。</p>
<p>所需的输入数据量取决于应用程序，<strong>但实验表明大约 500 张图像足以校准 ImageNet 分类网络。</strong></p>
<p>给定激活张量的统计数据，决定最佳尺度值并不是一门精确的科学——它需要平衡量化表示中的两个误差源：离散化误差（随着每个量化值表示的范围变大而增加）和截断误差（其中值被限制在可表示范围的极限）。因此，TensorRT 提供了多个不同的校准器，它们以不同的方式计算比例。较旧的校准器还为 GPU 执行层融合，以在执行校准之前优化掉不需要的张量。这在使用 DLA 时可能会出现问题，其中融合模式可能不同，并且可以使用<code>kCALIBRATE_BEFORE_FUSION</code>量化标志覆盖。</p>
<p><strong>校准批次大小也会影响IInt8EntropyCalibrator2和IInt8EntropyCalibrator的截断误差。</strong>例如，使用多个小批量校准数据进行校准可能导致直方图分辨率降低和标度值差。对于每个校准步骤，TensorRT更新每个激活张量的直方图分布。如果它在激活张量中遇到一个大于当前直方图最大值的值，则直方图范围将增加2的幂以适应新的最大值。这种方法效果很好，除非在最后一个校准步骤中重新分配直方图，导致最终的直方图中有一半是空的。这样的直方图可能产生较差的校准标度。这也使得校准容易受到校准批次顺序的影响，也就是说，不同的校准批次顺序可能导致直方图大小在不同点增加，从而产生略有不同的校准刻度。为了避免这个问题，请使用尽可能大的单个批次进行校准，并确保校准批次具有良好的随机性和相似的分布。</p>
<p><strong>IInt8EntropyCalibrator2</strong></p>
<p><strong>熵校准<code>Entropy calibration</code></strong>选择张量的比例因子来优化量化张量的信息论内容，通常会抑制分布中的异常值。这是当前推荐的熵校准器，是 DLA 所必需的。默认情况下，校准发生在图层融合之前。<strong>推荐用于基于 CNN 的网络。</strong></p>
<p><strong>IInt8MinMaxCalibrator</strong></p>
<p>该校准器使用激活分布的整个范围来确定比例因子。<strong>它似乎更适合 NLP 任务</strong>。默认情况下，校准发生在图层融合之前。推荐用于 NVIDIA BERT（谷歌官方实现的优化版本）等网络。</p>
<p><strong>IInt8EntropyCalibrator</strong></p>
<p>这是原始的熵校准器。它的使用没有<code>LegacyCalibrator</code> 复杂，通常会产生更好的结果。默认情况下，校准发生在图层融合之后。</p>
<p><strong>IInt8LegacyCalibrator</strong></p>
<p>该校准器与 TensorRT 2.0 EA 兼容。此校准器需要用户参数化，并且在其他校准器产生不良结果时作为备用选项提供。默认情况下，校准发生在图层融合之后。<strong>您可以自定义此校准器以实现最大百分比，例如，观察到 99.99% 的最大百分比对于 NVIDIA BERT 具有最佳精度</strong>。</p>
<p>构建 INT8 引擎时，构建器执行以下步骤：</p>
<ol>
<li><p>构建一个 32 位引擎，在校准集上运行它，并为激活值分布的每个张量记录一个直方图。</p>
</li>
<li><p>从直方图构建一个校准表，为每个张量提供一个比例值。</p>
</li>
<li><p>根据校准表和网络定义构建 INT8 引擎。</p>
</li>
</ol>
<p>校准可能很慢；因此步骤 2 的输出（校准表）可以被缓存和重用。这在多次构建相同的网络时非常有用，例如，在多个平台上 - 特别是，它可以简化工作流程，在具有离散 GPU 的机器上构建校准表，然后在嵌入式平台上重用它。可在此处找到样本校准表。<br>在运行校准之前，TensorRT 会查询校准器实现以查看它是否有权访问缓存表。如果是这样，它直接进行到上面的步骤 3。缓存数据作为指针和长度传递。</p>
<p>只要校准发生在层融合之前，校准缓存数据就可以在平台之间以及为不同设备构建引擎时移植。这意味着在默认情况下使用<code>IInt8EntropyCalibrator2或IInt8MinMaxCalibrator</code>校准器或设置<code>QuantizationFlag::kCALIBRATE_BEFORE_FUSION</code>时，校准缓存是可移植的。不能保证跨平台或设备的融合是相同的，因此在层融合之后进行校准可能不会产生便携式校准缓存。<br>除了量化激活，TensorRT 还必须量化权重。它使用对称量化和使用权重张量中找到的最大绝对值计算的量化比例。对于卷积、反卷积和全连接权重，尺度是每个通道的。</p>
<p>注意：当构建器配置为使用 INT8 I/O 时，TensorRT 仍希望校准数据位于 <code>FP32</code> 中。您可以通过将 INT8 I/O 校准数据转换为 <code>FP32</code> 精度来创建 <code>FP32</code> 校准数据。您还必须确保 <code>FP32</code>投射校准数据在<code>[-128.0F, 127.0F]</code>范围内，因此可以转换为 <code>INT8</code> 数据而不会造成任何精度损失。</p>
<p>INT8 校准可与动态范围 API 一起使用。手动设置动态范围会覆盖 INT8 校准生成的动态范围。</p>
<p>注意：校准是确定性的——也就是说，如果您在同一设备上以相同的顺序为 TensorRT 提供相同的校准输入，则生成的比例在不同的运行中将是相同的。当提供相同的校准输入时，当使用具有相同批量大小的相同设备生成时，校准缓存中的数据将按位相同。当使用不同的设备、不同的批量大小或使用不同的校准输入生成校准缓存时，不能保证校准缓存中的确切数据按位相同。</p>
<h3 id="7-3-1-INT8-Calibration-Using-C"><a href="#7-3-1-INT8-Calibration-Using-C" class="headerlink" title="7.3.1. INT8 Calibration Using C++"></a>7.3.1. INT8 Calibration Using C++</h3><p>要向 TensorRT 提供校准数据，请实现<code>IInt8Calibrator</code>接口。</p>
<p>关于这个任务</p>
<p>构建器调用校准器如下：</p>
<ul>
<li><p>首先，它查询接口的批次大小并调用<code>getBatchSize()</code>来确定预期的输入批次的大小。</p>
</li>
<li><p>然后，它反复调用<code>getBatch()</code>来获取批量输入。批次必须与<code>getBatchSize()</code>的批次大小完全相同。当没有更多批次时， <code>getBatch()</code>必须返回<code>false</code> 。</p>
</li>
</ul>
<p>实现校准器后，您可以配置构建器以使用它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config-&gt;<span class="built_in">setInt8Calibrator</span>(calibrator.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><br>要缓存校准表，请实现<code>writeCalibrationCache()</code>和<code>readCalibrationCache()</code>方法。</p>
<p>有关配置 INT8 校准器对象的更多信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/TensorRT/tree/main/samples/sampleINT8">sampleINT8</a> </p>
<h3 id="7-3-2-Calibration-Using-Python"><a href="#7-3-2-Calibration-Using-Python" class="headerlink" title="7.3.2. Calibration Using Python"></a>7.3.2. Calibration Using Python</h3><p>以下步骤说明了如何使用 Python API 创建 INT8 校准器对象。<br>程序</p>
<ol>
<li>导入 TensorRT：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorrt <span class="keyword">as</span> trt</span><br></pre></td></tr></table></figure></li>
<li>与测试/验证数据集类似，使用一组输入文件作为校准数据集。确保校准文件代表整个推理数据文件。为了让 TensorRT 使用校准文件，您必须创建一个批处理流对象。批处理流对象用于配置校准器。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NUM_IMAGES_PER_BATCH = <span class="number">5</span></span><br><span class="line">batchstream = ImageBatchStream(NUM_IMAGES_PER_BATCH, calibration_files)</span><br></pre></td></tr></table></figure></li>
<li>使用输入节点名称和批处理流创建一个Int8_calibrator对象：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int8_calibrator = EntropyCalibrator([<span class="string">&quot;input_node_name&quot;</span>], batchstream)</span><br></pre></td></tr></table></figure></li>
<li>设置 INT8 模式和 INT8 校准器：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.set_flag(trt.BuilderFlag.INT8)</span><br><span class="line">config.int8_calibrator = Int8_calibrator</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="7-4-Explicit-Quantization"><a href="#7-4-Explicit-Quantization" class="headerlink" title="7.4. Explicit Quantization"></a>7.4. Explicit Quantization</h2><p>当 TensorRT 检测到网络中存在 Q/DQ 层时，它会使用显式精度处理逻辑构建一个引擎。</p>
<p>AQ/DQ 网络必须在启用 INT8 精度构建器标志的情况下构建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config-&gt;<span class="built_in">setFlag</span>(BuilderFlag::kINT8);</span><br></pre></td></tr></table></figure>
<p>在显式量化中，表示与 INT8 之间的网络变化是显式的，因此，INT8 不能用作类型约束。</p>
<h3 id="7-4-1-Quantized-Weights"><a href="#7-4-1-Quantized-Weights" class="headerlink" title="7.4.1. Quantized Weights"></a>7.4.1. Quantized Weights</h3><p>Q/DQ 模型的权重必须使用 <code>FP32</code> 数据类型指定。 TensorRT 使用对权重进行操作的<code>IQuantizeLayer</code>的比例对权重进行量化。量化的权重存储在引擎文件中。也可以使用预量化权重，但必须使用 <code>FP32</code> 数据类型指定。 Q 节点的 <code>scale</code> 必须设置为<code>1.0F</code> ，但 <code>DQ</code> 节点必须是真实的 <code>scale</code> 值。</p>
<h3 id="7-4-2-ONNX-Support"><a href="#7-4-2-ONNX-Support" class="headerlink" title="7.4.2. ONNX Support"></a>7.4.2. ONNX Support</h3><p>当使用 <code>Quantization Aware Training (QAT)</code> 在 PyTorch 或 TensorFlow 中训练的模型导出到 ONNX 时，框架图中的每个伪量化操作都会导出为一对<code>QuantizeLinear</code>和<code>DequantizeLinear</code> ONNX 运算符。</p>
<p>当 TensorRT 导入 ONNX 模型时，ONNX <code>QuantizeLinear</code>算子作为<code>IQuantizeLayer</code>实例导入，ONNX <code>DequantizeLinear</code>算子作为<code>IDequantizeLayer</code>实例导入。</p>
<p>使用 <code>opset 10</code> 的 ONNX 引入了对 <code>QuantizeLinear/DequantizeLinear</code> 的支持，并且在 <code>opset 13</code> 中添加了量化轴属性（每通道量化所必需的）。 PyTorch 1.8 引入了对使用 <code>opset 13</code> 将 PyTorch 模型导出到 ONNX 的支持。</p>
<p>警告： ONNX GEMM 算子是一个可以按通道量化的示例。 PyTorch <code>torch.nn.Linear</code>层导出为 ONNX GEMM 算子，具有<code>(K, C)</code>权重布局并启用了<code>transB</code> GEMM 属性（这会在执行 GEMM 操作之前转置权重）。另一方面，TensorFlow在 ONNX 导出之前预转置权重<code>(C, K)</code> ：</p>
<p>PyTorch: $y = xW^T$</p>
<p>TensorFlow: $y = xW$</p>
<p>因此，PyTorch 权重由 TensorRT 转置。权重在转置之前由 TensorRT 进行量化，因此源自从 PyTorch 导出的 ONNX QAT 模型的 GEMM 层使用维度0进行每通道量化（轴K = 0 ）；而源自 TensorFlow 的模型使用维度1 （轴K = 1 ）。</p>
<p>TensorRT 不支持使用 INT8 张量或量化运算符的预量化 ONNX 模型。具体来说，以下 ONNX 量化运算符不受支持，如果在 TensorRT 导入 ONNX 模型时遇到它们，则会生成导入错误：</p>
<ul>
<li>QLinearConv/QLinearMatmul</li>
<li>ConvInteger/MatmulInteger</li>
</ul>
<h3 id="7-4-3-TensorRT-Processing-Of-Q-DQ-Networks"><a href="#7-4-3-TensorRT-Processing-Of-Q-DQ-Networks" class="headerlink" title="7.4.3. TensorRT Processing Of Q/DQ Networks"></a>7.4.3. TensorRT Processing Of Q/DQ Networks</h3><p>当 TensorRT 在 Q/DQ 模式下优化网络时，优化过程仅限于不改变网络算术正确性的优化。由于浮点运算的顺序会产生不同的结果（例如，重写 $a <em> s + b </em> s$ 为 $(a + b) * s$是一个有效的优化）。允许这些差异通常是后端优化的基础，这也适用于将具有 <code>Q/DQ</code> 层的图转换为使用 INT8 计算。</p>
<p>Q/DQ 层控制网络的计算和数据精度。 <code>IQuantizeLayer</code>实例通过量化将 <code>FP32</code> 张量转换为 <code>INT8</code> 张量， <code>IDequantizeLayer</code>实例通过反量化将INT8张量转换为 FP32 张量。 TensorRT 期望量化层的每个输入上都有一个 <code>Q/DQ</code> 层对。量化层是深度学习层，可以通过与<code>IQuantizeLayer</code>和<code>IDequantizeLayer</code>实例融合来转换为量化层。当 TensorRT 执行这些融合时，它会将可量化层替换为实际使用 INT8 计算操作对 INT8 数据进行操作的量化层。</p>
<p>对于本章中使用的图表，绿色表示 INT8 精度，蓝色表示浮点精度。箭头代表网络激活张量，正方形代表网络层。</p>
<p>下图. 可量化的<code>AveragePool</code>层（蓝色）与 <code>DQ</code> 层和 <code>Q</code> 层融合。所有三层都被量化的<code>AveragePool</code>层（绿色）替换。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq.png" class="">
<p>在网络优化期间，TensorRT 在称为 <code>Q/DQ</code> 传播的过程中移动 <code>Q/DQ</code> 层。传播的目标是最大化以低精度处理的图的比例。因此，TensorRT 向后传播 Q 节点（以便尽可能早地进行量化）和向前传播 DQ 节点（以便尽可能晚地进行去量化）。 Q-layers 可以与 <code>commute-with-Quantization</code> 层交换位置，DQ-layers 可以与 <code>commute-with-Dequantization</code> 层交换位置。</p>
<p>A layer Op commutes with quantization if $Q (Op (x) ) ==Op (Q (x) )$</p>
<p>Similarly, a layer Op commutes with dequantization if $Op (DQ (x) ) ==DQ (Op (x) )$</p>
<p>下图说明了 DQ 前向传播和 Q 后向传播。这些是对模型的合法重写，因为 <code>Max Pooling</code> 具有 INT8 实现，并且因为 Max Pooling 与 DQ 和 Q 通讯。</p>
<p>下图描述 DQ 前向传播和 Q 后向传播的插图。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-propagation.png" class="">
<p><strong>注意：</strong></p>
<p>为了理解最大池化交换，让我们看一下应用于某个任意输入的最大池化操作的输出。 <code>Max Pooling</code>应用于输入系数组并输出具有最大值的系数。对于由系数组成的组i ： ${x_0 . . x_m}$</p>
<p>$utput_i := max({x_0, x_1, … x_m}) = max({max({max({x_0, x_1}), x_2)}, … x_m})$</p>
<p>因此，在不失一般性（WLOG）的情况下查看两个任意系数就足够了：</p>
<p>$x_j = max({x_j, x_k})\ \ \ for\ \ \ x_j &gt;= x_k$</p>
<p>对于量化函数$Q(a, scale, x_max, x_min) := truncate(round(a/scale), x_max,x_min)$ 来说$scale&gt;0$, 注意（不提供证明，并使用简化符号):</p>
<p>$Q(x_j, scale) &gt;= Q(x_k, scale)\ \ \ for\ \ \ x_j &gt;= x_k$</p>
<p>因此：</p>
<p>$max({Q(x_j, scale), Q(x_k, scale)}) = Q(x_j, scale)\ \ \ for\ \ \ x_j &gt;= x_k$</p>
<p>然而，根据定义：</p>
<p>$Q(max({x_j, x_k}), scale) = Q(x_j, scale)\ \ \ for\ \ \ x_j &gt;= x_k$</p>
<p>函数 $max$ commutes-with-quantization 和 Max Pooling 也是如此。</p>
<p>类似地，对于去量化，函数$DQ (a, scale) :=a * scale  with scale&gt;0$  我们可以证明：</p>
<p>$max({DQ(x_j, scale), DQ(x_k, scale)}) = DQ(x_j, scale) = DQ(max({x_j, x_k}), scale)\ \ \ for\ \ \ x_j &gt;= x_k$</p>
<p>量化层和交换层的处理方式是有区别的。两种类型的层都可以在 INT8 中计算，但可量化层也与 DQ 输入层和 Q 输出层融合。例如， <code>AveragePooling</code>层（可量化）不与 Q 或 DQ 交换，因此使用 <code>Q/DQ</code> 融合对其进行量化，如第一张图所示。这与如何量化 <code>Max Pooling</code>（交换）形成对比。</p>
<h3 id="7-4-4-Q-DQ-Layer-Placement-Recommendations"><a href="#7-4-4-Q-DQ-Layer-Placement-Recommendations" class="headerlink" title="7.4.4. Q/DQ Layer-Placement Recommendations"></a>7.4.4. Q/DQ Layer-Placement Recommendations</h3><p>Q/DQ 层在网络中的放置会影响性能和准确性。由于量化引入的误差，激进量化会导致模型精度下降。但量化也可以减少延迟。此处列出了在网络中放置 Q/DQ 层的一些建议。</p>
<p>量化加权运算（卷积、转置卷积和 GEMM）的所有输入。权重和激活的量化降低了带宽需求，还使 INT8 计算能够加速带宽受限和计算受限的层。</p>
<p>下图 TensorRT 如何融合卷积层的两个示例。在左边，只有输入被量化。在右边，输入和输出都被量化了。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement1.png" class="">
<p>默认情况下，不量化加权运算的输出。保留更高精度的去量化输出有时很有用。例如，如果线性运算后面跟着一个激活函数（SiLU，下图中），它需要更高的精度输入才能产生可接受的精度。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement2.png" class="">
<p>不要在训练框架中模拟批量归一化和 ReLU 融合，因为 TensorRT 优化保证保留这些操作的算术语义。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement3.png" class="">
<p>TensorRT 可以在加权层之后融合element-wise addition，这对于像 ResNet 和 EfficientNet 这样具有跳跃连接的模型很有用。element-wise addition层的第一个输入的精度决定了融合输出的精度。</p>
<p>比如下图中，$x_f^1$的精度是浮点数，所以融合卷积的输出仅限于浮点数，后面的Q层不能和卷积融合。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement4.png" class="">
<p>相比之下，当$x_f^1$量化为 INT8 时，如下图所示，融合卷积的输出也是 INT8，尾部的 Q 层与卷积融合。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement5.png" class="">
<p>为了获得额外的性能，请尝试使用 Q/DQ 量化不交换的层。目前，具有 INT8 输入的非加权层也需要 INT8 输出，因此对输入和输出都进行量化。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-placement6.png" class="">
<p>如果 TensorRT 无法将操作与周围的 Q/DQ 层融合，则性能可能会降低，因此在添加 Q/DQ 节点时要保守，并牢记准确性和 TensorRT 性能进行试验。</p>
<p>下图是额外 Q/DQ 操作可能导致的次优融合示例（突出显示的浅绿色背景矩形）。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/sub-optimal.png" class="">
<p>对激活使用逐张量量化；和每个通道的权重量化。这种配置已经被经验证明可以带来最佳的量化精度。</p>
<p>您可以通过启用 <code>FP16</code> 进一步优化引擎延迟。 TensorRT 尽可能尝试使用 <code>FP16</code> 而不是 <code>FP32</code>（目前并非所有层类型都支持）</p>
<h3 id="7-4-5-Q-DQ-Limitations"><a href="#7-4-5-Q-DQ-Limitations" class="headerlink" title="7.4.5. Q/DQ Limitations"></a>7.4.5. Q/DQ Limitations</h3><p>TensorRT 执行的一些 Q/DQ 图重写优化比较两个或多个 Q/DQ 层之间的量化尺度值，并且仅在比较的量化尺度相等时才执行图重写。改装可改装的 TensorRT 引擎时，可以为 Q/DQ 节点的尺度分配新值。在 Q/DQ 引擎的改装操作期间，TensorRT 检查是否为参与尺度相关优化的 Q/DQ 层分配了破坏重写优化的新值，如果为真则抛出异常。</p>
<p>下比较 Q1 和 Q2 的尺度是否相等的示例，如果相等，则允许它们向后传播。如果使用 Q1 和 Q2 的新值对引擎进行改装，使得<code>Q1 != Q2</code> ，则异常中止改装过程。</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/q-dq-limitations.png" class="">
<h3 id="7-4-6-QAT-Networks-Using-TensorFlow"><a href="#7-4-6-QAT-Networks-Using-TensorFlow" class="headerlink" title="7.4.6. QAT Networks Using TensorFlow"></a>7.4.6. QAT Networks Using TensorFlow</h3><p>目前，没有用于 TensorRT 的 TensorFlow 量化工具包，但是，有几种推荐的方法：</p>
<ul>
<li>TensorFlow 2 引入了一个新的 API 来在 QAT（量化感知训练）中执行伪量化： <code>tf.quantization.quantize_and_dequantize_v2</code><br>该算子使用与 TensorRT 的量化方案一致的对称量化。我们推荐这个 API 而不是 TensorFlow 1 <code>tf.quantization.quantize_and_dequantize</code> API。<br>导出到 ONNX 时，可以使用tf2onnx转换器将<code>quantize_and_dequantize_v2</code>算子转换为一对 <code>QuantizeLinear</code> 和 <code>DequantizeLinear</code> 算子（Q/DQ 算子） 。请参阅<a target="_blank" rel="noopener" href="https://github.com/onnx/tensorflow-onnx/blob/master/tf2onnx/rewriter/quantization_ops_rewriter.py">quantization_ops_rewriter</a>以了解如何执行此转换。</li>
<li>默认情况下，TensorFlow 将<code>tf.quantization.quantize_and_dequantize_v2</code>算子（导出到 ONNX 后的 Q/DQ 节点）放在算子输出上，而 TensorRT 建议将 Q/DQ 放在层输入上。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html#qdq-placement-recs">QDQ </a>位置。</li>
<li>TensorFlow 1 不支持每通道量化 (PCQ)。建议将 PCQ 用于权重，以保持模型的准确性。</li>
</ul>
<h3 id="7-4-7-QAT-Networks-Using-PyTorch"><a href="#7-4-7-QAT-Networks-Using-PyTorch" class="headerlink" title="7.4.7. QAT Networks Using PyTorch"></a>7.4.7. QAT Networks Using PyTorch</h3><p>PyTorch 1.8.0 和前版支持 ONNX <a target="_blank" rel="noopener" href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#QuantizeLinear">QuantizeLinear</a> / <a target="_blank" rel="noopener" href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#dequantizelinear">DequantizeLinear</a> ，支持每通道缩放。您可以使用<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/TensorRT/tree/main/tools/pytorch-quantization">pytorch-quantization</a>进行 INT8 校准，运行量化感知微调，生成 ONNX，最后使用 TensorRT 在此 ONNX 模型上运行推理。更多详细信息可以在<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/tensorrt/pytorch-quantization-toolkit/docs/index.html">PyTorch-Quantization Toolkit</a> 用户指南中找到。</p>
<h2 id="7-5-INT8-Rounding-Modes"><a href="#7-5-INT8-Rounding-Modes" class="headerlink" title="7.5. INT8 Rounding Modes"></a>7.5. INT8 Rounding Modes</h2><p><div class="tablenoborder"><a name="int8-rounding-modes__table_fwf_vxy_gpb" shape="rect">
                              <!-- --></a><table cellpadding="4" cellspacing="0" summary="" id="int8-rounding-modes__table_fwf_vxy_gpb" class="table" frame="border" border="1" rules="all">
                              <thead class="thead" align="left">
                                 <tr class="row">
                                    <th class="entry" rowspan="2" valign="top" width="25%" id="d54e7059" colspan="1">Backend</th>
                                    <th class="entry" rowspan="2" valign="top" width="25%" id="d54e7062" colspan="1">Compute Kernel Quantization (FP32 to INT8)</th>
                                    <th class="entry" colspan="2" valign="top" id="d54e7065" rowspan="1">Weights Quantization (FP32 to INT8)</th>
                                 </tr>
                                 <tr class="row">
                                    <th class="entry" valign="top" width="25%" id="d54e7071" rowspan="1" colspan="1">Quantized Network (QAT)</th>
                                    <th class="entry" valign="top" width="25%" id="d54e7074" rowspan="1" colspan="1">Dynamic Range API / Calibration</th>
                                 </tr>
                              </thead>
                              <tbody class="tbody">
                                 <tr class="row">
                                    <td class="entry" valign="top" width="25%" headers="d54e7059 d54e7071" rowspan="1" colspan="1">GPU</td>
                                    <td class="entry" valign="top" width="25%" headers="d54e7062 d54e7074" rowspan="1" colspan="1"><samp class="ph codeph">round-to-nearest-with-ties-to-even</samp></td>
                                    <td class="entry" valign="top" width="25%" headers="d54e7065" rowspan="1" colspan="1"><samp class="ph codeph">round-to-nearest-with-ties-to-even</samp></td>
                                    <td class="entry" valign="top" width="25%" headers="d54e7065" rowspan="1" colspan="1"><samp class="ph codeph">round-to-nearest-with-ties-to-positive-infinity</samp></td>
                                 </tr>
                                 <tr class="row">
                                    <td class="entry" valign="top" width="25%" headers="d54e7059 d54e7071" rowspan="1" colspan="1">DLA</td>
                                    <td class="entry" valign="top" width="25%" headers="d54e7062 d54e7074" rowspan="1" colspan="1"><samp class="ph codeph">round-to-nearest-with-ties-away-from-zero</samp></td>
                                    <td class="entry" valign="top" width="25%" headers="d54e7065" rowspan="1" colspan="1">N/A</td>
                                    <td class="entry" valign="top" width="25%" headers="d54e7065" rowspan="1" colspan="1"><samp class="ph codeph">round-to-nearest-with-ties-away-from-zero</samp></td>
                                 </tr>
                              </tbody>
                           </table>
                        </div></p>
<h2 id="7-6-Calibration-file"><a href="#7-6-Calibration-file" class="headerlink" title="7.6 Calibration file"></a>7.6 Calibration file</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.ccoderun.ca/programming/doxygen/tensorrt/md_TensorRT_samples_opensource_sampleINT8_README.html#calibration-file">https://www.ccoderun.ca/programming/doxygen/tensorrt/md_TensorRT_samples_opensource_sampleINT8_README.html#calibration-file</a></p>
<p>校准文件存储每个网络张量的激活尺度。激活尺度是使用校准算法生成的动态范围来计算的<code>`abs(max_dynamic_range) / 127.0f</code>. 。如7.3节描述的<code>IInt8EntropyCalibrator2</code>就是使用的<code>熵校准 Entropy calibration</code></p>
<p>校准文件名为CalibrationTable＜NetworkName＞，其中＜NetworkName＜是网络的名称，例如mnist。该文件位于TensorRT-x.x.x/data/mnist目录中，其中x.x.x.x是您安装的TensorRT版本。</p>
<p>如果没有找到CalibrationTable文件，构建器将再次运行校准算法来创建它。校准表的内容包括</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TRT-7000-EntropyCalibration2</span><br><span class="line">data: 3c008912</span><br><span class="line">conv1: 3c88edfc</span><br><span class="line">pool1: 3c88edfc</span><br><span class="line">conv2: 3ddc858b</span><br><span class="line">pool2: 3ddc858b</span><br><span class="line">ip1: 3db6bd6e</span><br><span class="line">ip2: 3e691968</span><br><span class="line">prob: 3c010a14</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><p><code>&lt;TRT xxxx&gt;-&lt;xxxxxxx&gt;</code>TensorRT版本后面跟着校准算法，例如<code>EntropyCalibration2</code>。</p>
</li>
<li><p><code>＜layer name＞：值</code>对应于网络中每个张量在校准期间确定的浮点激活标度。</p>
</li>
</ul>
<p><code>CalibrationTable</code>文件是在运行校准算法的构建阶段生成的。创建校准文件后，可以读取该文件以进行后续运行，而无需再次运行校准。您可以提供<code>readCalibrationCache（）</code>的实现，以从所需位置加载校准文件。如果读取的校准文件与校准器类型（用于生成文件）和<code>TensorRT</code>版本兼容，构建器将跳过校准步骤，转而使用校准文件中的每个张量标度值。</p>
<h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS:"></a>TIPS:</h1><ul>
<li><p>INT8量化后生成的<code>engine</code>输入输出类型会变化吗？</p>
<p>答：不会变化：生成的engine输入输出还是和onnx的输入输出一样，例如是fp32或者int32等，但是<strong>中间层可能是量化的精度，例如是INT8和INT16的混合</strong>。见下图是官方的profile_tensorrt_resnet50_int8.ipynb文件里面的图片，可以看到输入还是FP32，第一层就是一个<code>Reformat</code>转换为了<code>Int8</code>。这些信息在使用trtexec生成int8 的engine时都会有打印输出。这是是使用官方的工具绘制出来的engine结构。绘制engine结构的官方工具TREx之后介绍，参考链接<a target="_blank" rel="noopener" href="https://developer.nvidia.com/blog/exploring-tensorrt-engines-with-trex/">https://developer.nvidia.com/blog/exploring-tensorrt-engines-with-trex/</a></p>
<p>INT8量化后resnet50的engine输入如下：</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519160545371.png" class="" title="image-20240519160545371">
<p>INT8量化后resnet50的engine输出如下：</p>
<img src="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/image-20240519160746455.png" class="" title="image-20240519160746455">
</li>
</ul>
<h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><p>官方：<a target="_blank" rel="noopener" href="https://developer.nvidia.com/blog/achieving-fp32-accuracy-for-int8-inference-using-quantization-aware-training-with-tensorrt/">Achieving FP32 Accuracy for INT8 Inference Using Quantization Aware Training with NVIDIA TensorRT</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>奔跑的IC
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/7-TensorRT%E4%B8%AD%E7%9A%84INT8/" title="7-TensorRT中的INT8">http://example.com/TensorRT/TensorRT中文版开发手册/7-TensorRT中的INT8/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/git/" rel="tag"><i class="fa fa-tag"></i> git</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/GPU/" rel="tag"><i class="fa fa-tag"></i> GPU</a>
              <a href="/tags/Tensorrt/" rel="tag"><i class="fa fa-tag"></i> Tensorrt</a>
              <a href="/tags/DeepLearning/" rel="tag"><i class="fa fa-tag"></i> DeepLearning</a>
              <a href="/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> 卷积神经网络</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/6-TensorRT%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" rel="prev" title="6-TensorRT高级用法">
                  <i class="fa fa-chevron-left"></i> 6-TensorRT高级用法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/TensorRT/TensorRT%E4%B8%AD%E6%96%87%E7%89%88%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/8-TensorRT%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%BD%A2%E7%8A%B6/" rel="next" title="8-TensorRT中的动态形状">
                  8-TensorRT中的动态形状 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">奔跑的IC</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"zmurder","repo":"zmurder.github.io","client_id":"cf2343f27b6c29efe0bc","client_secret":"3268a1fa92706c7358d5421f88f76a0f7ada3188","admin_user":"zmurder","distraction_free_mode":true,"proxy":"https://strong-caramel-969805.netlify.app/github_access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"4fd0bdfd62a2959a570ba65fd63266ef"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
