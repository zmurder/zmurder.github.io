<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8693861384618000"
     crossorigin="anonymous"></script>
  <meta name="msvalidate.01" content="7EC20DBC74B004C2782077570E15C280">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8693861384618000"
     crossorigin="anonymous"></script>
    <meta name="description" content="3 protobuf C++开发3.1 为什么要用protobuf">
<meta property="og:type" content="article">
<meta property="og:title" content="3 protobuf使用">
<meta property="og:url" content="http://example.com/protobuf/3%20protobuf%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="奔跑的IC">
<meta property="og:description" content="3 protobuf C++开发3.1 为什么要用protobuf">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/protobuf/3%20protobuf%E4%BD%BF%E7%94%A8/image-20220327222818195.png">
<meta property="article:published_time" content="2024-12-01T10:13:45.775Z">
<meta property="article:modified_time" content="2024-12-01T10:13:45.775Z">
<meta property="article:author" content="奔跑的IC">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="protobuf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/protobuf/3%20protobuf%E4%BD%BF%E7%94%A8/image-20220327222818195.png">


<link rel="canonical" href="http://example.com/protobuf/3%20protobuf%E4%BD%BF%E7%94%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://example.com/protobuf/3%20protobuf%E4%BD%BF%E7%94%A8/","path":"protobuf/3 protobuf使用/","title":"3 protobuf使用"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>3 protobuf使用 | 奔跑的IC</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">奔跑的IC</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-reorder fa-fw"></i>文章列表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#3-protobuf-C-%E5%BC%80%E5%8F%91"><span class="nav-text">3 protobuf C++开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8protobuf"><span class="nav-text">3.1 为什么要用protobuf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">3.2 示例代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%AE%9A%E4%B9%89proto%E6%A0%BC%E5%BC%8F"><span class="nav-text">3.3 定义proto格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E7%BC%96%E8%AF%91proto%E6%96%87%E4%BB%B6"><span class="nav-text">3.4 编译proto文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-The-Protocol-Buffer-API"><span class="nav-text">3.5 The Protocol Buffer API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E5%9F%BA%E6%9C%AC%E7%9A%84API"><span class="nav-text">3.5.1 基本的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E5%85%B6%E4%BB%96API"><span class="nav-text">3.5.2 其他API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="nav-text">3.6 枚举和嵌套类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E6%A0%87%E5%87%86Message%E6%96%B9%E6%B3%95"><span class="nav-text">3.7 标准Message方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E8%A7%A3%E6%9E%90%EF%BC%89"><span class="nav-text">3.8 序列化和反序列化（解析）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-%E5%86%99Message"><span class="nav-text">3.9 写Message</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-3-5%E8%AF%BBMessage"><span class="nav-text">3.10 3.5读Message</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11-%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%AF%BB%E5%86%99Message%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">3.11 另一个读写Message的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-12-%E6%89%A9%E5%B1%95%E4%B8%80%E4%B8%AA-Protocol-Buffer"><span class="nav-text">3.12 扩展一个 Protocol Buffer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-text">附录</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="奔跑的IC"
      src="/images/zyd.gif">
  <p class="site-author-name" itemprop="name">奔跑的IC</p>
  <div class="site-description" itemprop="description">死磕牛角的IT农民工</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">185</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/protobuf/3%20protobuf%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zyd.gif">
      <meta itemprop="name" content="奔跑的IC">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔跑的IC">
      <meta itemprop="description" content="死磕牛角的IT农民工">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="3 protobuf使用 | 奔跑的IC">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          3 protobuf使用
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-01 18:13:45" itemprop="dateCreated datePublished" datetime="2024-12-01T18:13:45+08:00">2024-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/protobuf/" itemprop="url" rel="index"><span itemprop="name">protobuf</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="3-protobuf-C-开发"><a href="#3-protobuf-C-开发" class="headerlink" title="3 protobuf C++开发"></a>3 protobuf C++开发</h1><h2 id="3-1-为什么要用protobuf"><a href="#3-1-为什么要用protobuf" class="headerlink" title="3.1 为什么要用protobuf"></a>3.1 为什么要用protobuf</h2><p>我们将要使用的示例是一个非常简单的 “地址簿” 应用程序，可以在文件中读写联系人的详细信息。地址簿中的每个人都有姓名、ID、电子邮件地址和联系电话。</p>
<p>你该如何序列化和反序列化如上结构的数据呢？这里有几种解决方案：</p>
<ul>
<li>可以以二进制形式发送/保存原始内存中数据结构。随着时间的推移，这是一种脆弱的方法，<strong>因为接收/读取代码必须使用完全相同的内存布局、字节顺序等进行编译</strong>。此外，由于文件以原始格式累积数据，并且解析该格式的软件副本四处传播，因此很难扩展格式。</li>
<li>你可以发明一种特殊的方法将数据项编码为单个字符串 - 例如将 4 个整数编码为 “12:3:-23:67”。这是一种简单而灵活的方法，虽然它确实需要编写一次性编码和解析的代码，并且解析会产生一些小的运行时成本。但这非常适合非常简单的数据的编码。</li>
<li>将数据序列化为 XML。这种方法非常有吸引力，因为 XML（差不多）是人类可读的，并且有许多语言的绑定库。如果你想与其他应用程序/项目共享数据，这可能是一个不错的选择。然而，XML 是众所周知需要更多的空间，并且编码/解码 XML 会对应用程序造成巨大的性能损失。此外，导航 XML DOM 树比通常在类中导航简单字段要复杂得多。</li>
</ul>
<p>而 Protocol buffers 是灵活，高效，自动化的解决方案。采用 protocol buffers，你可以写一个 <code>.proto</code> 文件描述你想要读取的数据的结构。由此， protocol buffer 编译器将创建一个类，该类使用有效的二进制格式实现 protocol buffer 数据的自动编码和解析。生成的类为构成 protocol buffer 的字段提供 getter 和 setter，并负责读写 protocol buffer 单元的细节。重要的是，protocol buffer 的格式支持随着时间的推移扩展格式的想法，使得代码仍然可以读取用旧格式编码的数据。</p>
<h2 id="3-2-示例代码"><a href="#3-2-示例代码" class="headerlink" title="3.2 示例代码"></a>3.2 示例代码</h2><p>示例代码包含在源代码包中的 “examples” 目录下，<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/downloads">Download it here.</a></p>
<h2 id="3-3-定义proto格式"><a href="#3-3-定义proto格式" class="headerlink" title="3.3 定义proto格式"></a>3.3 定义proto格式</h2><p>要创建地址簿应用程序，你需要从 .proto 文件开始。.proto 文件中的定义很简单：为要序列化的每个数据结构添加 message 定义，然后为 message 中的每个字段指定名称和类型。下面就是定义相关 message 的 .proto 文件，addressbook.proto。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  optional <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  optional int32 id = <span class="number">2</span>;</span><br><span class="line">  optional <span class="built_in">string</span> email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> &#123;</span></span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    optional <span class="built_in">string</span> number = <span class="number">1</span>;</span><br><span class="line">    optional PhoneType type = <span class="number">2</span> [<span class="keyword">default</span> = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一行指定正在使用<code>proto2</code>语法：如果不这样做，协议缓冲区编译器将假定正在使用proto2。<strong>这也必须是文件的第一个非空的非注释行</strong>。<strong>如果使用proto3必须修改为<code>proto3</code></strong></p>
<p>注意：如果上面的proto使用proto3来编译的话会报错，因为proto3删除了required修饰符，需要删除修饰符再编译,另外默认值也删除<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/proto3#default">参考</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addressbook.proto:6:12: Explicit &#x27;optional&#x27; labels are disallowed in the Proto3 syntax. To define &#x27;optional&#x27; fields in Proto3, simply remove the &#x27;optional&#x27; label, as fields are &#x27;optional&#x27; by default.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/protobuf/3%20protobuf%E4%BD%BF%E7%94%A8/image-20220327222818195.png" class="" title="image-20220327222818195">
</li>
<li><p>package 声明：这有助于防止不同项目之间的命名冲突。在 C++ 中，生成的类将放在与包名匹配的 namespace （命名空间）中。例如定一个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tutorial::AddressBook address_book;</span><br></pre></td></tr></table></figure>
</li>
<li><p>message 定义：message 只是包含一组类型字段的集合。许多标准的简单数据类型都可用作字段类型，包括 bool、int32、float、double 和 string。你还可以使用其他 message 类型作为字段类型在消息中添加更多结构 - 在上面的示例中，Person 包含 PhoneNumber message ，而 AddressBook 包含 Person message。你甚至可以定义嵌套在其他 message 中的 message 类型 - 如你所见，PhoneNumber 类型在 Person 中定义。如果你希望其中一个字段具有预定义的值列表中的值，你还可以定义枚举类型 - 此处你指定（枚举）电话号码，它的值可以是 MOBILE，HOME 或 WORK 之一。</p>
</li>
<li><p>唯一的编号标签：代表每个字段的一个唯一的编号标签，在同一个消息里不可以重复。这些编号标签用与在消息二进制格式中标识你的字段，并且消息一旦定义就不能更改。需要说明的是标签在1到15范围的采用一个字节进行编码，所以通常将标签1到15用于频繁发生的消息字段。编号标签大小的范围是1到2的29次。19000-19999是官方预留的值，不能使用。</p>
</li>
<li><p>注释格式：向.proto文件添加注释，可以使用C/C++/java/Go风格的双斜杠（//） 语法格式或者/<em>…..</em>/</p>
</li>
<li><p>必须使用以下修饰符之一注释每个字段：</p>
<ul>
<li><strong>required</strong>: 必须提供该字段的值，否则该消息将被视为“未初始化”。如果是在调试模式下编译 libprotobuf，则序列化一个未初始化的 message 将将导致断言失败。在优化的构建中，将跳过检查并始终写入消息。但是，解析未初始化的消息将始终失败（通过从解析方法返回 false）。除此之外，required 字段的行为与 optional 字段完全相同。<strong>在proto3中字段规则移除了 “required”</strong>不建议使用。</li>
<li><strong>optional</strong>: 可以设置也可以不设置该字段。如果未设置可选字段值，则使用默认值。对于简单类型，你可以指定自己的默认值，就像我们在示例中为电话号码类型所做的那样。否则，使用系统默认值：数字类型为 0，字符串为空字符串，bools 为 false。对于嵌入 message，默认值始终是消息的 “默认实例” 或 “原型”，其中没有设置任何字段。调用访问器以获取尚未显式设置的 optional（或 required）字段的值始终返回该字段的默认值。</li>
<li><strong>repeated</strong>: 该字段可以重复任意次数（包括零次）。重复值的顺序将保留在 protocol buffer 中。可以将 repeated 字段视为动态大小的数组。</li>
</ul>
</li>
</ul>
<h2 id="3-4-编译proto文件"><a href="#3-4-编译proto文件" class="headerlink" title="3.4 编译proto文件"></a>3.4 编译proto文件</h2><p>已经有了一个 <code>.proto</code> 文件，可以生成需要读写<code>AddressBook</code>（以及 <code>Person</code> 和 <code>PhoneNumber</code> ） message 所需的类。为此，你需要在 <code>.proto</code> 上运行 protocol buffer 编译器 <code>protoc</code>：</p>
<ol>
<li><p>如果尚未安装编译器，请 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fdownloads.html">下载软件包</a> 并按照 README 文件中的说明进行操作。</p>
</li>
<li><p>运行编译器，<strong>指定源目录</strong>（应用程序的源代码所在的位置 - 如果不提供值，则使用当前目录），<strong>目标目录</strong>（你希望生成代码的目标目录;通常与源目录 <code>$SRC_DIR</code> 相同），以及 <code>.proto</code> 的路径。执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=src --cpp_out=build/gen src/foo.proto src/bar/baz.proto</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-I 指定proto文件所在的路径 ，是--proto_path的缩写 上面就是在src目录下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cpp_out指定生成的cc和h文件路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后是proto文件名 如果有多个ptoto可以空格追加</span></span><br></pre></td></tr></table></figure>
<p>因为你需要 C ++ 类，所以使用 <code>--cpp_out</code> 选项 - 当然，为其他支持的语言也提供了类似的选项。</p>
<p>这将在指定的目标目录中生成以下文件：</p>
<ul>
<li><code>addressbook.pb.h</code>： 类声明的头文件</li>
<li><code>addressbook.pb.cc</code>：类实现</li>
</ul>
</li>
<li><p>可以从生成的.h文件开始部分中看出对应的proto版本，例如下面的表示使用3.5.5版本生成的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_sim0322_2eproto__INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_sim0322_2eproto__INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/stubs/common.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GOOGLE_PROTOBUF_VERSION &lt; 3005000</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> This file was generated by a newer version of protoc which is</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> incompatible with your Protocol Buffer headers.  Please update</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> your headers.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 3005000 &lt; GOOGLE_PROTOBUF_MIN_PROTOC_VERSION</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> This file was generated by an older version of protoc which is</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> incompatible with your Protocol Buffer headers.  Please</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> regenerate this file with a newer version of protoc.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-5-The-Protocol-Buffer-API"><a href="#3-5-The-Protocol-Buffer-API" class="headerlink" title="3.5 The Protocol Buffer API"></a>3.5 The Protocol Buffer API</h2><p>让我们看看一些生成的代码，看看编译器为你创建了哪些类和函数。如果你查看　addressbook.pb.h，你会发现你在 addressbook.proto 中指定的每条 message 都有一个对应的类。仔细观察 Person 类，你可以看到编译器已为每个字段生成了访问器。例如，对于 name ，id，email 和 phone 字段，你可以使用以下方法（proto2生成的如下）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">has_name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear_name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> ::<span class="function">std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> ::std::string&amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> ::<span class="function">std::string* <span class="title">mutable_name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">has_id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear_id</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title">id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">int32_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// email</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">has_email</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear_email</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> ::<span class="function">std::string&amp; <span class="title">email</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_email</span><span class="params">(<span class="type">const</span> ::std::string&amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_email</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> ::<span class="function">std::string* <span class="title">mutable_email</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// phones</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">phones_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear_phones</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> ::google::<span class="function">protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;&amp; <span class="title">phones</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">inline</span> ::google::<span class="function">protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;* <span class="title">mutable_phones</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> ::<span class="function">tutorial::Person_PhoneNumber&amp; <span class="title">phones</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">inline</span> ::<span class="function">tutorial::Person_PhoneNumber* <span class="title">mutable_phones</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> ::<span class="function">tutorial::Person_PhoneNumber* <span class="title">add_phones</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>proto3生成的如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// repeated .tutorial.Person.PhoneNumber phones = 4;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">phones_size</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_phones</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kPhonesFieldNumber = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> ::tutorial::Person_PhoneNumber&amp; <span class="title function_">phones</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span>;</span><br><span class="line">::tutorial::Person_PhoneNumber* <span class="title function_">mutable_phones</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">::tutorial::Person_PhoneNumber* <span class="title function_">add_phones</span><span class="params">()</span>;</span><br><span class="line">::google::protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;*</span><br><span class="line">    <span class="title function_">mutable_phones</span><span class="params">()</span>;</span><br><span class="line"><span class="type">const</span> ::google::protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;&amp;</span><br><span class="line">    <span class="title function_">phones</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string name = 1;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_name</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNameFieldNumber = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title function_">name</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_name</span><span class="params">(<span class="type">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>&amp; value)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LANG_CXX11</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_name</span><span class="params">(::<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; value)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value, <span class="type">size_t</span> size)</span>;</span><br><span class="line">::<span class="built_in">std</span>::<span class="built_in">string</span>* <span class="title function_">mutable_name</span><span class="params">()</span>;</span><br><span class="line">::<span class="built_in">std</span>::<span class="built_in">string</span>* <span class="title function_">release_name</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_allocated_name</span><span class="params">(::<span class="built_in">std</span>::<span class="built_in">string</span>* name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string email = 3;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_email</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kEmailFieldNumber = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title function_">email</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_email</span><span class="params">(<span class="type">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>&amp; value)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LANG_CXX11</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_email</span><span class="params">(::<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; value)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_email</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_email</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value, <span class="type">size_t</span> size)</span>;</span><br><span class="line">::<span class="built_in">std</span>::<span class="built_in">string</span>* <span class="title function_">mutable_email</span><span class="params">()</span>;</span><br><span class="line">::<span class="built_in">std</span>::<span class="built_in">string</span>* <span class="title function_">release_email</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_allocated_email</span><span class="params">(::<span class="built_in">std</span>::<span class="built_in">string</span>* email)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int32 id = 2;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_id</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kIdFieldNumber = <span class="number">2</span>;</span><br><span class="line">::google::protobuf::int32 <span class="title function_">id</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_id</span><span class="params">(::google::protobuf::int32 value)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-1-基本的API"><a href="#3-5-1-基本的API" class="headerlink" title="3.5.1 基本的API"></a>3.5.1 基本的API</h3><p>针对proto3生成的分析，下面的都是基于proto3来说明</p>
<p>例如数字id字段</p>
<ul>
<li><p>get的名称与字段完全相同的<strong>小写</strong>，例如email()</p>
</li>
<li><p>set方法以<code>set_</code>开头</p>
</li>
<li><p>对于required和optional字段，有<code>has_</code>方法，如果有值就会返回true(<strong>proto3没有</strong>)</p>
</li>
<li><p>每个字段都有一个 clear_ 方法，可以将字段重新设置回 empty 状态</p>
</li>
</ul>
<h3 id="3-5-2-其他API"><a href="#3-5-2-其他API" class="headerlink" title="3.5.2 其他API"></a>3.5.2 其他API</h3><p>针对string类型有几个额外的方法（上面的方法也有），例如name和email字段</p>
<ul>
<li>赋值方法除了set_name还有mutable_name和set_allocated_email方法<ul>
<li>set_name方法和set_allocated_email都是传入的指针，<strong>赋值时需要注意如果是传入的是临时变量的地址，需要注意临时变量的生命周期，如果序列化之前被释放了就会出错</strong>。</li>
<li>mutable_name方法，<strong>赋值时候，可以使用局部变量，因为在调用的时，内部做了new操作。</strong></li>
</ul>
</li>
</ul>
<p>repeated 字段也有一些特殊的方法，例如phone字段</p>
<ul>
<li><p>返回数组中成员数 _size（关联的电话号码数），例如 phones_size()</p>
</li>
<li><p>返回数组中指定下标所包含元素的引用，如 使用索引获取电话号码，例如phones(int index)</p>
</li>
<li><p>返回数组中指定下标所包含元素的指针，如mutable_phones(int index)，可以修改里面的内容</p>
</li>
<li><p>向数组中添加一个新的元素，add_方法，返回一个新添加元素的指针，例如add_phones()，add后可以调用set，例如下面，具体使用的整体例子看下面的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tutorial::Person::PhoneNumber* phone_number = person-&gt;<span class="built_in">add_phones</span>();</span><br><span class="line">    phone_number-&gt;<span class="built_in">set_number</span>(number);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-6-枚举和嵌套类"><a href="#3-6-枚举和嵌套类" class="headerlink" title="3.6 枚举和嵌套类"></a>3.6 枚举和嵌套类</h2><p>生成的代码包含与你的 .proto 枚举对应的 PhoneType 枚举。你可以将此类型称为 Person::PhoneType，其值为 Person::MOBILE，Person::HOME 和 Person::WORK（实现细节稍微复杂一些，但你如果仅仅只是使用不需要理解里面的实现原理）。</p>
<p>编译器还为你生成了一个名为 Person::PhoneNumber 的嵌套类。如果查看代码，可以看到 “真实” 类实际上称为 Person_PhoneNumber，但在 Person 中定义的 typedef 允许你将其视为嵌套类。唯一会造成一点差异的情况是，如果你想在另一个文件中前向声明该类 - 你不能在 C ++ 中前向声明嵌套类型，但你可以前向声明 Person_PhoneNumber。</p>
<h2 id="3-7-标准Message方法"><a href="#3-7-标准Message方法" class="headerlink" title="3.7 标准Message方法"></a>3.7 标准Message方法</h2><p>每个 message 类还包含许多其他方法，可用于检查或操作整个 message，包括：</p>
<ul>
<li><code>bool IsInitialized() const;</code>: 检查是否已设置所有必填 required 字段</li>
<li><p><code>string DebugString() const;</code>: 返回 message 的人类可读表达，对调试特别有用</p>
</li>
<li><p><code>void CopyFrom(const Person&amp; from);</code>: 用给定的 message 的值覆盖 message</p>
</li>
<li><code>void Clear();</code>: 将所有元素清除回 empty 状态</li>
</ul>
<p>这些和下一节中描述的 I/O 方法实现了所有 C++ protocol buffer 类共享的 <code>Message</code> 接口。更多的更详细的有关信息，请参阅 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Freference%2Fcpp%2Fgoogle.protobuf.message.html%23Message">Message 的完整 API 文档</a>。</p>
<h2 id="3-8-序列化和反序列化（解析）"><a href="#3-8-序列化和反序列化（解析）" class="headerlink" title="3.8 序列化和反序列化（解析）"></a>3.8 序列化和反序列化（解析）</h2><ul>
<li><p>每个 message类都提供了写入和读取 message数据的方法，包括</p>
<ul>
<li>bool SerializeToString(string* output) const; 把 message编码进 output 。</li>
<li>bool ParseFromString(const string&amp; data); 从 string 解码到 message</li>
<li>bool SerializeToArray(char* buf,int size) const; 把 message编码进数组 buf.</li>
<li>bool ParseFromArray(const char* buf,int size); 把 buf 解码到 message。解 码方法效率较 ParseFromString高很多，所以一般用这种方法解码。</li>
<li>bool SerializeToOstream(ostream* output) const; 把 message编码进 ostream</li>
<li>bool ParseFromIstream(istream* input); 从 istream 解码到 message</li>
</ul>
<p>备注：发送接收端所使用的加码解码方法不一定非得配对，即发送端用 SerializeToString 接收端不一定非得用 ParseFromString ，可以使用其他解码方法。</p>
</li>
</ul>
<p>这些只是解析和序列化提供的几个选项。请参阅 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Freference%2Fcpp%2Fgoogle.protobuf.message.html%23Message">Message API 参考</a> 以获取完整列表。</p>
<p>下面是编译的protobuf头文件中关于序列化和反序列化的声明在/opt/libs-x64/protobuf/protobuf-3.5.0/include/google/protobuf/message_lite.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parsing ---------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Methods for parsing in protocol buffer format.  Most of these are</span></span><br><span class="line"><span class="comment">// just simple wrappers around MergeFromCodedStream().  Clear() will be</span></span><br><span class="line"><span class="comment">// called before merging the input.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill the message with a protocol buffer parsed from the given input</span></span><br><span class="line"><span class="comment">// stream. Returns false on a read error or if the input is in the wrong</span></span><br><span class="line"><span class="comment">// format.  A successful return does not indicate the entire input is</span></span><br><span class="line"><span class="comment">// consumed, ensure you call ConsumedEntireMessage() to check that if</span></span><br><span class="line"><span class="comment">// applicable.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParseFromCodedStream</span><span class="params">(io::CodedInputStream* input)</span>;</span><br><span class="line"><span class="comment">// Like ParseFromCodedStream(), but accepts messages that are missing</span></span><br><span class="line"><span class="comment">// required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParsePartialFromCodedStream</span><span class="params">(io::CodedInputStream* input)</span>;</span><br><span class="line"><span class="comment">// Read a protocol buffer from the given zero-copy input stream.  If</span></span><br><span class="line"><span class="comment">// successful, the entire input will be consumed.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParseFromZeroCopyStream</span><span class="params">(io::ZeroCopyInputStream* input)</span>;</span><br><span class="line"><span class="comment">// Like ParseFromZeroCopyStream(), but accepts messages that are missing</span></span><br><span class="line"><span class="comment">// required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParsePartialFromZeroCopyStream</span><span class="params">(io::ZeroCopyInputStream* input)</span>;</span><br><span class="line"><span class="comment">// Read a protocol buffer from the given zero-copy input stream, expecting</span></span><br><span class="line"><span class="comment">// the message to be exactly &quot;size&quot; bytes long.  If successful, exactly</span></span><br><span class="line"><span class="comment">// this many bytes will have been consumed from the input.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParseFromBoundedZeroCopyStream</span><span class="params">(io::ZeroCopyInputStream* input, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// Like ParseFromBoundedZeroCopyStream(), but accepts messages that are</span></span><br><span class="line"><span class="comment">// missing required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParsePartialFromBoundedZeroCopyStream</span><span class="params">(io::ZeroCopyInputStream* input,</span></span><br><span class="line"><span class="params">                                           <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// Parses a protocol buffer contained in a string. Returns true on success.</span></span><br><span class="line"><span class="comment">// This function takes a string in the (non-human-readable) binary wire</span></span><br><span class="line"><span class="comment">// format, matching the encoding output by MessageLite::SerializeToString().</span></span><br><span class="line"><span class="comment">// If you&#x27;d like to convert a human-readable string into a protocol buffer</span></span><br><span class="line"><span class="comment">// object, see google::protobuf::TextFormat::ParseFromString().</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParseFromString</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; data)</span>;</span><br><span class="line"><span class="comment">// Like ParseFromString(), but accepts messages that are missing</span></span><br><span class="line"><span class="comment">// required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParsePartialFromString</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; data)</span>;</span><br><span class="line"><span class="comment">// Parse a protocol buffer contained in an array of bytes.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParseFromArray</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// Like ParseFromArray(), but accepts messages that are missing</span></span><br><span class="line"><span class="comment">// required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ParsePartialFromArray</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reads a protocol buffer from the stream and merges it into this</span></span><br><span class="line"><span class="comment">// Message.  Singular fields read from the input overwrite what is</span></span><br><span class="line"><span class="comment">// already in the Message and repeated fields are appended to those</span></span><br><span class="line"><span class="comment">// already present.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is the responsibility of the caller to call input-&gt;LastTagWas()</span></span><br><span class="line"><span class="comment">// (for groups) or input-&gt;ConsumedEntireMessage() (for non-groups) after</span></span><br><span class="line"><span class="comment">// this returns to verify that the message&#x27;s end was delimited correctly.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ParsefromCodedStream() is implemented as Clear() followed by</span></span><br><span class="line"><span class="comment">// MergeFromCodedStream().</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MergeFromCodedStream</span><span class="params">(io::CodedInputStream* input)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like MergeFromCodedStream(), but succeeds even if required fields are</span></span><br><span class="line"><span class="comment">// missing in the input.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// MergeFromCodedStream() is just implemented as MergePartialFromCodedStream()</span></span><br><span class="line"><span class="comment">// followed by IsInitialized().</span></span><br><span class="line">virtual <span class="type">bool</span> <span class="title function_">MergePartialFromCodedStream</span><span class="params">(io::CodedInputStream* input)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Serialization ---------------------------------------------------</span></span><br><span class="line"><span class="comment">// Methods for serializing in protocol buffer format.  Most of these</span></span><br><span class="line"><span class="comment">// are just simple wrappers around ByteSize() and SerializeWithCachedSizes().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write a protocol buffer of this message to the given output.  Returns</span></span><br><span class="line"><span class="comment">// false on a write error.  If the message is missing required fields,</span></span><br><span class="line"><span class="comment">// this may GOOGLE_CHECK-fail.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SerializeToCodedStream</span><span class="params">(io::CodedOutputStream* output)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">// Like SerializeToCodedStream(), but allows missing required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SerializePartialToCodedStream</span><span class="params">(io::CodedOutputStream* output)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">// Write the message to the given zero-copy output stream.  All required</span></span><br><span class="line"><span class="comment">// fields must be set.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SerializeToZeroCopyStream</span><span class="params">(io::ZeroCopyOutputStream* output)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">// Like SerializeToZeroCopyStream(), but allows missing required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SerializePartialToZeroCopyStream</span><span class="params">(io::ZeroCopyOutputStream* output)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">// Serialize the message and store it in the given string.  All required</span></span><br><span class="line"><span class="comment">// fields must be set.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SerializeToString</span><span class="params">(<span class="built_in">string</span>* output)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">// Like SerializeToString(), but allows missing required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SerializePartialToString</span><span class="params">(<span class="built_in">string</span>* output)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">// Serialize the message and store it in the given byte array.  All required</span></span><br><span class="line"><span class="comment">// fields must be set.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SerializeToArray</span><span class="params">(<span class="type">void</span>* data, <span class="type">int</span> size)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">// Like SerializeToArray(), but allows missing required fields.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SerializePartialToArray</span><span class="params">(<span class="type">void</span>* data, <span class="type">int</span> size)</span> <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-写Message"><a href="#3-9-写Message" class="headerlink" title="3.9 写Message"></a>3.9 写Message</h2><p>下面地址簿应用程序能够做的第一件事是将个人详细信息写入地址簿文件。为此，您需要创建并填充协议缓冲区类的实例，然后将它们写入输出流。下面是一个程序，它从一个文件中读取一个AddressBook，根据用户输入添加一个新的Person到它，并再次将新的AddressBook写回文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;addressbook.pb.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function fills in a Person message based on user input.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PromptForAddress</span><span class="params">(tutorial::Person* person)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Enter person ID number: &quot;</span>;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  cin &gt;&gt; id;</span><br><span class="line">  person-&gt;<span class="built_in">set_id</span>(id);<span class="comment">//直接调用set方法设置id</span></span><br><span class="line">  cin.<span class="built_in">ignore</span>(<span class="number">256</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Enter name: &quot;</span>;</span><br><span class="line">  <span class="built_in">getline</span>(cin, *person-&gt;<span class="built_in">mutable_name</span>());<span class="comment">//注意这里字符串的赋值方式不是set方法</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Enter email address (blank for none): &quot;</span>;</span><br><span class="line">  string email;</span><br><span class="line">  <span class="built_in">getline</span>(cin, email);</span><br><span class="line">  <span class="keyword">if</span> (!email.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    person-&gt;<span class="built_in">set_email</span>(email);<span class="comment">//这里也是字符串的赋值，但是用的set方法，email临时变量，不懂string类型。还是不要用了</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a phone number (or leave blank to finish): &quot;</span>;</span><br><span class="line">    string number;</span><br><span class="line">    <span class="built_in">getline</span>(cin, number);</span><br><span class="line">    <span class="keyword">if</span> (number.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//person里面的repeated修饰的phone_number 需要先add 然后set</span></span><br><span class="line">    <span class="comment">//需要定义一个tutorial::Person::PhoneNumber指针类型 因为person的add函数返回的是该类型的指针，在这个指针上set就改变了person里面的number</span></span><br><span class="line">    tutorial::Person::PhoneNumber* phone_number = person-&gt;<span class="built_in">add_phones</span>();</span><br><span class="line">    phone_number-&gt;<span class="built_in">set_number</span>(number);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is this a mobile, home, or work phone? &quot;</span>;</span><br><span class="line">    string type;</span><br><span class="line">    <span class="built_in">getline</span>(cin, type);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;mobile&quot;</span>) &#123;</span><br><span class="line">      phone_number-&gt;<span class="built_in">set_type</span>(tutorial::Person::MOBILE);<span class="comment">//枚举类型使用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;home&quot;</span>) &#123;</span><br><span class="line">      phone_number-&gt;<span class="built_in">set_type</span>(tutorial::Person::HOME);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;work&quot;</span>) &#123;</span><br><span class="line">      phone_number-&gt;<span class="built_in">set_type</span>(tutorial::Person::WORK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Unknown phone type.  Using default.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function:  Reads the entire address book from a file,</span></span><br><span class="line"><span class="comment">//   adds one person based on user input, then writes it back out to the same</span></span><br><span class="line"><span class="comment">//   file.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Verify that the version of the library that we linked against is</span></span><br><span class="line">  <span class="comment">// compatible with the version of the headers we compiled against.</span></span><br><span class="line">  GOOGLE_PROTOBUF_VERIFY_VERSION;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Usage:  &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; ADDRESS_BOOK_FILE&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tutorial::AddressBook address_book;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>], ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">      cout &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;: File not found.  Creating a new file.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!address_book.<span class="built_in">ParseFromIstream</span>(&amp;input)) &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;Failed to parse address book.&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an address. 调用add函数添加一个people</span></span><br><span class="line">  <span class="built_in">PromptForAddress</span>(address_book.<span class="built_in">add_people</span>());</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Write the new address book back to disk.</span></span><br><span class="line">    <span class="function">fstream <span class="title">output</span><span class="params">(argv[<span class="number">1</span>], ios::out | ios::trunc | ios::binary)</span></span>;</span><br><span class="line">   	<span class="comment">//序列化</span></span><br><span class="line">      <span class="keyword">if</span> (!address_book.<span class="built_in">SerializeToOstream</span>(&amp;output)) &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;Failed to write address book.&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional:  Delete all global objects allocated by libprotobuf.</span></span><br><span class="line">  google::protobuf::<span class="built_in">ShutdownProtobufLibrary</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在程序结束时调用 ShutdownProtobufLibrary()。所有这一切都是删除 Protocol Buffer 库分配的所有全局对象。对于大多数程序来说这是不必要的，因为该过程无论如何都要退出，并且操作系统将负责回收其所有内存。但是，如果你使用了内存泄漏检查程序，该程序需要释放每个最后对象，或者你正在编写可以由单个进程多次加载和卸载的库，那么你可能希望强制使用 Protocol Buffers 来清理所有内容。</p>
<p>把proto文件放在这里方便查阅</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  optional string name = <span class="number">1</span>;</span><br><span class="line">  optional int32 id = <span class="number">2</span>;</span><br><span class="line">  optional string email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">PhoneType</span> &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    optional string number = <span class="number">1</span>;</span><br><span class="line">    optional PhoneType type = <span class="number">2</span> [<span class="keyword">default</span> = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-10-3-5读Message"><a href="#3-10-3-5读Message" class="headerlink" title="3.10 3.5读Message"></a>3.10 3.5读Message</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;addressbook.pb.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterates though all people in the AddressBook and prints info about them.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListPeople</span><span class="params">(<span class="type">const</span> tutorial::AddressBook&amp; address_book)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取people元素的数量 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; address_book.<span class="built_in">people_size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">//因为是repeated修饰符 因此定义一个tutorial::Person&amp; person类型，获取元素个数</span></span><br><span class="line">      <span class="comment">//&amp;是一个引用，也就是变量的别名。参考 https://blog.csdn.net/qq_25814297/article/details/103829775</span></span><br><span class="line">    <span class="type">const</span> tutorial::Person&amp; person = address_book.<span class="built_in">people</span>(i);</span><br><span class="line">	<span class="comment">//获取id</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person ID: &quot;</span> &lt;&lt; person.<span class="built_in">id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//获取字符类型的name 和获取id一样</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;  Name: &quot;</span> &lt;&lt; person.<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (person.<span class="built_in">has_email</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;  E-mail address: &quot;</span> &lt;&lt; person.<span class="built_in">email</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//同样PhoneNumber是 repeated修饰符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; person.<span class="built_in">phones_size</span>(); j++) &#123;</span><br><span class="line">      <span class="type">const</span> tutorial::Person::PhoneNumber&amp; phone_number = person.<span class="built_in">phones</span>(j);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (phone_number.<span class="built_in">type</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> tutorial::Person::MOBILE:</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;  Mobile phone #: &quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> tutorial::Person::HOME:</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;  Home phone #: &quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> tutorial::Person::WORK:</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;  Work phone #: &quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; phone_number.<span class="built_in">number</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function:  Reads the entire address book from a file and prints all</span></span><br><span class="line"><span class="comment">//   the information inside.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Verify that the version of the library that we linked against is</span></span><br><span class="line">  <span class="comment">// compatible with the version of the headers we compiled against.</span></span><br><span class="line">  GOOGLE_PROTOBUF_VERIFY_VERSION;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Usage:  &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; ADDRESS_BOOK_FILE&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tutorial::AddressBook address_book;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>], ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">if</span> (!address_book.<span class="built_in">ParseFromIstream</span>(&amp;input)) &#123;</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;Failed to parse address book.&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ListPeople</span>(address_book);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional:  Delete all global objects allocated by libprotobuf.</span></span><br><span class="line">  google::protobuf::<span class="built_in">ShutdownProtobufLibrary</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-11-另一个读写Message的例子"><a href="#3-11-另一个读写Message的例子" class="headerlink" title="3.11 另一个读写Message的例子"></a>3.11 另一个读写Message的例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;addressbook.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    addressbook::AddressBook person;</span><br><span class="line">    addressbook::Person* pi = person.<span class="built_in">add_person_info</span>();</span><br><span class="line"></span><br><span class="line">    pi-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;aut&quot;</span>);</span><br><span class="line">    pi-&gt;<span class="built_in">set_id</span>(<span class="number">1219</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before clear(), id = &quot;</span> &lt;&lt; pi-&gt;<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    pi-&gt;<span class="built_in">clear_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after  clear(), id = &quot;</span> &lt;&lt; pi-&gt;<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    pi-&gt;<span class="built_in">set_id</span>(<span class="number">1087</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pi-&gt;<span class="built_in">has_email</span>())</span><br><span class="line">        pi-&gt;<span class="built_in">set_email</span>(<span class="string">&quot;autyinjing@126.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    addressbook::Person::PhoneNumber* pn = pi-&gt;<span class="built_in">add_phone</span>();</span><br><span class="line">    pn-&gt;<span class="built_in">set_number</span>(<span class="string">&quot;021-8888-8888&quot;</span>);</span><br><span class="line">    pn = pi-&gt;<span class="built_in">add_phone</span>();</span><br><span class="line">    pn-&gt;<span class="built_in">set_number</span>(<span class="string">&quot;138-8888-8888&quot;</span>);</span><br><span class="line">    pn-&gt;<span class="built_in">set_type</span>(addressbook::Person::MOBILE);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> size = person.<span class="built_in">ByteSize</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byteArray[size];</span><br><span class="line">    person.<span class="built_in">SerializeToArray</span>(byteArray, size);</span><br><span class="line"></span><br><span class="line">    addressbook::AddressBook help_person;</span><br><span class="line">    help_person.<span class="built_in">ParseFromArray</span>(byteArray, size);</span><br><span class="line">    addressbook::Person help_pi = help_person.<span class="built_in">person_info</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*****************************&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;id:    &quot;</span> &lt;&lt; help_pi.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name:  &quot;</span> &lt;&lt; help_pi.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;email: &quot;</span> &lt;&lt; help_pi.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; help_pi.<span class="built_in">phone_size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> help_pn = help_pi.<span class="built_in">mutable_phone</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;phone_type: &quot;</span> &lt;&lt; help_pn-&gt;<span class="built_in">type</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;phone_number: &quot;</span> &lt;&lt; help_pn-&gt;<span class="built_in">number</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*****************************&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-12-扩展一个-Protocol-Buffer"><a href="#3-12-扩展一个-Protocol-Buffer" class="headerlink" title="3.12 扩展一个 Protocol Buffer"></a>3.12 扩展一个 Protocol Buffer</h2><p>在发布使用 protocol buffer 的代码之后，无疑早晚有一天你将会想要 “改进” protocol buffer 的定义。如果你希望你的新 buffer 向后兼容，并且你的旧 buffer 是向前兼容的（实际上你一定想要这种兼容性） - 那么你需要遵循一些规则。在新版本的 protocol buffer 中：</p>
<ul>
<li><strong>你不得更改任何现有字段的字段编号</strong></li>
<li><strong>你不得添加或删除任何 required 字段</strong></li>
<li><strong>你可以删除 optional 或 repeated 的字段</strong></li>
<li><strong>你可以添加新的 optional 或 repeated 字段，但必须使用新的标记号（即从未在此协议缓冲区中使用的编号，甚至包括那些已删除的字段的编号）</strong></li>
</ul>
<p>（这些规则有一些 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fproto%23updating">例外</a>，但它们很少使用）。</p>
<p>如果你遵循这些规则，旧代码将很乐意阅读新消息并简单地忽略任何新字段。对于旧代码，已删除的可选字段将只具有其默认值，删除的重复字段将为空。新代码也将透明地读取旧消息。但是，请记住旧的 message 中不会出现新的可选字段，因此你需要明确通过调用  has<em> 方法来检查它们是否被设置，或者在字段编号后面使用 [default = value] 在 .proto 文件中提供合理的默认值。如果未为 optional 元素指定默认值，则使用特定于类型的默认值：对于字符串，默认值为空字符串。对于布尔值，默认值为 false。对于数字类型，默认值为零。另请注意，如果添加了新的 repeated 字段，则新代码将无法判断它是否为空（通过新代码）或从未设置（通过旧代码），因为它没有 has</em> 标志。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>protobuf 官网：<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers">https://developers.google.cn/protocol-buffers</a></p>
<p>官方教程：<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/overview">https://developers.google.cn/protocol-buffers/docs/overview</a></p>
<p>博客参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bdd94a32fbd1">ProtoBuf 官方文档（一）- 开发者指南</a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/autyinjing/p/6495103.html">Protobuf学习 - 入门</a> [protobuf 使用](</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>奔跑的IC
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/protobuf/3%20protobuf%E4%BD%BF%E7%94%A8/" title="3 protobuf使用">http://example.com/protobuf/3 protobuf使用/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/protobuf/" rel="tag"><i class="fa fa-tag"></i> protobuf</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/protobuf/protobuf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="protobuf学习笔记">
                  <i class="fa fa-chevron-left"></i> protobuf学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/protobuf/2%20protobuf%20proto3%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/" rel="next" title="2 protobuf proto3语言指南">
                  2 protobuf proto3语言指南 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">奔跑的IC</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"zmurder","repo":"zmurder.github.io","client_id":"cf2343f27b6c29efe0bc","client_secret":"3268a1fa92706c7358d5421f88f76a0f7ada3188","admin_user":"zmurder","distraction_free_mode":true,"proxy":"https://strong-caramel-969805.netlify.app/github_access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"f8988542632b652700f467e5457eddd2"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
