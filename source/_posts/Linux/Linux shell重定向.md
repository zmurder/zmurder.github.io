# 1 简介

在 Linux 的 shell 中，重定向是将命令的输入和输出重定向到不同的位置（如文件、设备或其他命令）。这使得 shell 可以灵活地处理数据流和日志记录。重定向主要涉及以下几种类型：标准输入（stdin）、标准输出（stdout）和标准错误输出（stderr）。

**文件描述符**

当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：

| 类型                        | 文件描述符 | 默认情况               | 对应文件句柄位置 |
| --------------------------- | ---------- | ---------------------- | ---------------- |
| 标准输入（standard input）  | 0          | 从键盘获得输入         | /proc/self/fd/0  |
| 标准输出（standard output） | 1          | 输出到屏幕（即控制台） | /proc/self/fd/1  |
| 错误输出（error output）    | 2          | 输出到屏幕（即控制台） | /proc/self/fd/2  |

所以我们平时在执行shell命令中，都默认是从键盘获得输入，并且将结果输出到控制台上。但是我们可以通过更改文件描述符默认的指向，从而实现输入输出的重定向。比如我们将1指向文件，那么标准的输出就会输出到文件中。

# 2 输出重定向

输出重定向的使用方式很简单，基本的一些命令如下：

输出重定向命令及其说明

| 介绍                                                   | 示例                                      | 解释                                                         |
| ------------------------------------------------------ | ----------------------------------------- | ------------------------------------------------------------ |
| 把标准输出重定向到新文件中，若文件已存在则覆盖         | `ls > output.txt`                         | 将 `ls` 命令的标准输出写入 `output.txt`，若文件已存在则覆盖其内容 |
| 同上，明确指定标准输出                                 | `ls 1> output.txt`                        | 同上，明确指定标准输出                                       |
| 把标准输出追加到文件中，若文件不存在则创建             | `ls >> output.txt`                        | 将 `ls` 命令的标准输出追加到 `output.txt`，若文件不存在则创建 |
| 同上，明确指定标准输出                                 | `ls 1>> output.txt`                       | 同上，明确指定标准输出                                       |
| 把标准错误重定向到新文件中，若文件已存在则覆盖         | `ls non_existing_file 2> error.txt`       | 将 `ls` 命令的标准错误写入 `error.txt`，若文件已存在则覆盖其内容 |
| 把标准错误追加到文件中，若文件不存在则创建             | `ls non_existing_file 2>> error.txt`      | 将 `ls` 命令的标准错误追加到 `error.txt`，若文件不存在则创建 |
| 把标准输出和标准错误都重定向到同一个新文件中           | `ls non_existing_file > output.txt 2>&1`  | 将 `ls` 命令的标准输出和标准错误都写入 `output.txt`，若文件已存在则覆盖其内容 |
| 把标准输出和标准错误都追加到同一个文件中               | `ls non_existing_file >> output.txt 2>&1` | 将 `ls` 命令的标准输出和标准错误都追加到 `output.txt`，若文件不存在则创建 |
| 把标准输出和标准错误都重定向到新文件中（Bash特有）     | `ls non_existing_file &> output.txt`      | 将 `ls` 命令的标准输出和标准错误都写入 `output.txt`，若文件已存在则覆盖其内容（Bash特有） |
| 把标准输出和标准错误都追加到文件中（Bash特有）         | `ls non_existing_file &>> output.txt`     | 将 `ls` 命令的标准输出和标准错误都追加到 `output.txt`，若文件不存在则创建（Bash特有） |
| 把标准错误重定向到标准输出，然后将标准输出重定向到文件 | `ls non_existing_file 2>&1 > output.txt`  | 先将 `ls` 命令的标准错误重定向到标准输出，然后将标准输出写入 `output.txt` |
| 把标准输出重定向到标准错误                             | `ls 1>&2`                                 | 将 `ls` 命令的标准输出重定向到标准错误                       |
| 把标准输出重定向到空设备，丢弃输出                     | `ls > /dev/null`                          | 将 `ls` 命令的标准输出重定向到 `/dev/null`，丢弃所有输出     |
| 把标准错误重定向到空设备，丢弃错误输出                 | `ls non_existing_file 2> /dev/null`       | 将 `ls` 命令的标准错误重定向到 `/dev/null`，丢弃所有错误输出 |
| 把标准输出和标准错误都重定向到空设备，丢弃所有输出     | `ls non_existing_file > /dev/null 2>&1`   | 将 `ls` 命令的标准输出和标准错误都重定向到 `/dev/null`，丢弃所有输出 |

我们使用>或者>>对输出进行重定向。符号的左边表示文件描述符，如果没有的话表示1，也就是标准输出，符号的右边可以是一个文件，也可以是一个输出设备。当使用>时，会判断右边的文件存不存在，如果存在的话就先删除，然后创建一个新的文件，不存在的话则直接创建。但是当使用>>进行追加时，则不会删除原来已经存在的文件。

## 2.1  `/dev/null`

`/dev/null` 是一个特殊的文件，通常被称为“空设备”。将输出重定向到 `/dev/null` 可以有效地丢弃不需要的输出。

## 2.2 `2>&1`

`2>&1` 用于将标准错误（文件描述符 2）重定向到标准输出（文件描述符 1）。这意味着错误消息将与标准输出混合在一起。

# 3 输入重定向

### 输入重定向命令及其说明

| 命令                   | 介绍                                        | 示例                             | 解释                                                         |
| ---------------------- | ------------------------------------------- | -------------------------------- | ------------------------------------------------------------ |
| `command < filename`   | 将文件内容作为命令的标准输入                | `sort < unsorted.txt`            | 将 `unsorted.txt` 的内容作为 `sort` 命令的输入，输出排序后的内容 |
| `command << EOF`       | Here Document，将多行文本作为命令的标准输入 | `cat << EOF\nHello\nWorld\nEOF`  | 将多行文本 "Hello\nWorld\n" 作为 `cat` 命令的输入，输出 "Hello\nWorld\n" |
| `command <<< "string"` | Here String，将字符串作为命令的标准输入     | `grep "Hello" <<< "Hello World"` | 将字符串 "Hello World" 作为 `grep` 命令的输入，查找 "Hello" 子字符串 |

